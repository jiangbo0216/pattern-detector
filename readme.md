## pattern detect

算法的思路类似递归下降算法，归纳出几类类型
- abcde 类型
- WanClub
- 豹子手机号
- 0x
- 420
- 000
- 国旗
- 日语
- 中文
- 阿语
- 360
- 生日
- 99
- 88
- 69
- ...

根据递归下降的思路，为每一个类型构建一个 parse 算法

### bad

- 代码在判断 X 模式 和特殊的数字的模式写的略显啰嗦，后续可以使用类似 checkAbc 的声明式的方式处理，目前先不进行处理
- parsePatterns 中有的模式判断没有完全遵循 每个类型一个 parse 的写法，时间有效，不做处理

### 两次遍历

did 一个域名可以对应多个模式，传统的递归下降依赖 pos 一个字符一个字符处理的话，需要多只回溯，处理起来比较复杂

所以我们大多数的时候选择两次遍历
1. 遍历字符串确认字符是满足规则的
2. 判断各个位置的字符的关系来分析模式

### 算法演进

#### 前期
在 ABCD 判断中，通过每个具体位置的字符判断模式

在代码中

- parse0x
- parse3AbcPattern

直接对每一个具体位置的字符判断得出模式，这种方式极为低效，无法复用

#### 后期
抽象字符判断，通过循环判断模式

我们希望复用 parse3AbcPattern parse5number 方法中的字符判断方法，我们抽象出了 checkAbc

我们可以告诉 checkAbc 哪些位置的是相同的，比如 



```js
// checkAbc 模式 -> 字符串
{
 a: [[0,1], [3,5]],
 b: [[1,3]]
}
```
这样 checkAbc 去检查 ABBCC 类型的模式

通过这个思路，我们可以逆向思考，我们可以通过遍历一遍 字符串 ，然后得出来类似的结果

```js
// parseAbcde 字符串 -> 模式
{
 a: [[0,1], [3,5]],
 b: [[1,3]]
}
```

通过一次循环我们可以得出字符串的 ABC 模式


## 测试

### fixtures

保存了所有类型的测试用例

### 封装
单元测试文件中我们看到有对单元测试进行抽象的写法，这样可以减少代码，但是由于众多的单测交织在一起，不利于测试。

所以倾向于在适度的范围内，尽量不要过度封装

### 检测

使用

- toEqual 
- toContain

检测 Set 的值

## Next

- 格式化工具
- commit 格式化
- changlog 生成等等